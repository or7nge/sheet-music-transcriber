#!/usr/bin/env python3
"""
Sheet Music Transcriber
Upload piano sheet music images/PDFs and get ABC notation, MIDI, and MusicXML output.
"""

import gradio as gr
import tempfile
import os
from pathlib import Path
import subprocess
import shutil
from typing import Tuple, Optional
import sys

# Check for required dependencies
try:
    from music21 import converter, stream
    import cv2
    from pdf2image import convert_from_path
except ImportError as e:
    print(f"Missing dependency: {e}")
    print("Please run: pip install -r requirements.txt")
    sys.exit(1)


def check_homr_installation() -> bool:
    """Check if homr is installed via poetry."""
    try:
        # Check in the homr directory
        homr_dir = "/Users/andrew/Documents/git/homr"
        result = subprocess.run(
            ["poetry", "run", "homr", "--help"],
            capture_output=True,
            text=True,
            timeout=10,
            cwd=homr_dir
        )
        return result.returncode == 0
    except (subprocess.SubprocessError, FileNotFoundError):
        return False


def convert_pdf_to_images(pdf_path: str, output_dir: str) -> list[str]:
    """Convert PDF pages to JPG images."""
    try:
        images = convert_from_path(pdf_path, dpi=300)
        image_paths = []
        for i, image in enumerate(images):
            output_path = os.path.join(output_dir, f"page_{i+1}.jpg")
            image.save(output_path, "JPEG")
            image_paths.append(output_path)
        return image_paths
    except Exception as e:
        raise Exception(f"PDF conversion failed: {str(e)}")


def process_with_homr(image_path: str, output_dir: str) -> Optional[str]:
    """
    Process sheet music image with homr to generate MusicXML.
    Returns path to generated MusicXML file or None on failure.
    """
    try:
        # Run homr via poetry from the homr directory
        homr_dir = "/Users/andrew/Documents/git/homr"
        result = subprocess.run(
            ["poetry", "run", "homr", image_path],
            capture_output=True,
            text=True,
            cwd=homr_dir,
            timeout=120
        )

        if result.returncode != 0:
            error_msg = result.stderr or result.stdout
            raise Exception(f"homr processing failed: {error_msg}")

        # Find generated MusicXML file - homr outputs to the same directory as the input
        image_dir = os.path.dirname(image_path)
        image_name = os.path.splitext(os.path.basename(image_path))[0]
        musicxml_path = os.path.join(image_dir, f"{image_name}.musicxml")

        if not os.path.exists(musicxml_path):
            raise Exception("No MusicXML file generated by homr")

        return musicxml_path

    except subprocess.TimeoutExpired:
        raise Exception("Processing timeout - image may be too complex")
    except Exception as e:
        raise Exception(f"homr error: {str(e)}")


def musicxml_to_abc(musicxml_path: str) -> str:
    """Convert MusicXML to ABC notation using music21."""
    try:
        score = converter.parse(musicxml_path)

        # Generate ABC manually since music21's ABC export is limited
        abc_lines = []
        abc_lines.append("X:1")
        abc_lines.append("T:Transcribed Sheet Music")
        abc_lines.append("M:4/4")  # Default time signature
        abc_lines.append("L:1/4")  # Default note length
        abc_lines.append("K:C")    # Default key

        # Try to extract actual metadata
        if score.metadata:
            if score.metadata.title:
                abc_lines[1] = f"T:{score.metadata.title}"

        # Get time signature from first measure
        ts = score.recurse().getElementsByClass('TimeSignature')
        if ts:
            abc_lines[2] = f"M:{ts[0].numerator}/{ts[0].denominator}"

        # Get key signature
        ks = score.recurse().getElementsByClass('KeySignature')
        if ks:
            key_obj = ks[0].asKey()
            # Format key properly for ABC
            tonic = key_obj.tonic.name
            mode = key_obj.mode
            if mode == 'minor':
                abc_lines[4] = f"K:{tonic}m"
            else:
                abc_lines[4] = f"K:{tonic}"

        abc_lines.append("")
        abc_lines.append("% Standard ABC notation (with octaves):")
        abc_lines.append("")

        # Chordify the score - this properly groups simultaneous notes into chords
        # and handles cases where notes have different durations
        try:
            chordified = score.chordify()
        except:
            # Fallback if chordify fails
            abc_lines.append("% Could not properly analyze chords")
            abc_lines.append("% Please use MusicXML output for accurate representation")
            return "\n".join(abc_lines)

        # Get time signature for measure boundaries
        time_sig = chordified.recurse().getElementsByClass('TimeSignature')
        measure_length = time_sig[0].barDuration.quarterLength if time_sig else 4.0

        current_measure_length = 0

        # Process the chordified score
        for measure in chordified.getElementsByClass('Measure'):
            measure_items = []

            for element in measure.flatten().notesAndRests:
                if element.isChord:
                    # Get all pitches in the chord
                    pitches = list(element.pitches)
                    # Sort from lowest to highest
                    pitches.sort(key=lambda p: p.ps)

                    # Convert to ABC
                    chord_notes = [pitch_to_abc(p) for p in pitches]
                    duration_str = duration_to_abc(element.quarterLength)

                    if len(pitches) > 1:
                        measure_items.append("[" + "".join(chord_notes) + "]" + duration_str)
                    else:
                        # Single note (shouldn't happen in chordified, but handle it)
                        measure_items.append(chord_notes[0] + duration_str)

                elif element.isNote:
                    # Single note
                    abc_note = pitch_to_abc(element.pitch)
                    duration_str = duration_to_abc(element.quarterLength)
                    measure_items.append(abc_note + duration_str)

                elif element.isRest:
                    # Rest
                    duration_str = duration_to_abc(element.quarterLength)
                    measure_items.append("z" + duration_str)

            # Add measure with bar line
            if measure_items:
                abc_lines.append(" ".join(measure_items) + " |")

        # Add simplified chord list (just letter names, no octaves)
        abc_lines.append("")
        abc_lines.append("% Simplified chord list (letter names only):")
        chords_simple = []
        for measure in chordified.getElementsByClass('Measure'):
            for element in measure.flatten().notesAndRests:
                if element.isChord:
                    pitches = list(element.pitches)
                    pitches.sort(key=lambda p: p.ps)
                    # Just the step letters
                    chord_letters = ''.join([p.step for p in pitches])
                    chords_simple.append(chord_letters)

        if chords_simple:
            abc_lines.append(" | ".join(chords_simple))

        return "\n".join(abc_lines)

    except Exception as e:
        return f"Error converting to ABC: {str(e)}\n\n(ABC conversion is experimental - use MusicXML for best results)"


def pitch_to_abc(pitch, simple_letters=True) -> str:
    """Convert music21 pitch to ABC notation."""
    if simple_letters:
        # Use just the letter name (step) without accidentals
        # This matches typical chord notation like "BDFB"
        note_name = pitch.step
    else:
        # Full ABC notation with accidentals
        note_name = pitch.name.replace('-', '_').replace('#', '^')

    octave = pitch.octave

    # ABC octave notation:
    # C4 (middle C) = C
    # C5 = c, C6 = c', C7 = c''
    # C3 = C,, C2 = C,,,
    if octave >= 5:
        abc_note = note_name.lower()
        abc_note += "'" * (octave - 5)
    elif octave == 4:
        abc_note = note_name.upper()
    else:
        abc_note = note_name.upper()
        abc_note += "," * (4 - octave)

    return abc_note


def duration_to_abc(quarter_length: float) -> str:
    """Convert music21 quarter length to ABC duration."""
    # ABC durations: no suffix = 1 quarter, 2 = half, /2 = eighth, etc.
    if quarter_length == 4:
        return "4"  # whole note
    elif quarter_length == 3:
        return "3"  # dotted half
    elif quarter_length == 2:
        return "2"  # half note
    elif quarter_length == 1.5:
        return "3/2"  # dotted quarter
    elif quarter_length == 1:
        return ""  # quarter note (default)
    elif quarter_length == 0.75:
        return "3/4"  # dotted eighth
    elif quarter_length == 0.5:
        return "/2"  # eighth note
    elif quarter_length == 0.25:
        return "/4"  # sixteenth note
    else:
        # For other durations, try to represent as fraction
        if quarter_length > 1:
            return str(int(quarter_length)) if quarter_length == int(quarter_length) else f"{quarter_length}"
        else:
            return f"/{int(1/quarter_length)}" if (1/quarter_length) == int(1/quarter_length) else f"/{quarter_length}"


def musicxml_to_midi(musicxml_path: str, output_path: str) -> str:
    """Convert MusicXML to MIDI using music21."""
    try:
        score = converter.parse(musicxml_path)
        score.write('midi', fp=output_path)
        return output_path
    except Exception as e:
        raise Exception(f"MIDI conversion failed: {str(e)}")


def process_sheet_music(file) -> Tuple[str, str, str, str]:
    """
    Main processing function.
    Returns: (abc_text, midi_path, musicxml_path, status_message)
    """
    if file is None:
        return "", None, None, "‚ùå Please upload a file"

    # Check homr installation
    if not check_homr_installation():
        return "", None, None, (
            "‚ùå homr is not installed!\n\n"
            "Please install homr:\n"
            "1. Clone: git clone https://github.com/liebharc/homr.git\n"
            "2. cd homr\n"
            "3. poetry install --only main\n"
            "4. poetry run homr --init\n"
            "5. Return to this directory and run the app"
        )

    temp_dir = tempfile.mkdtemp()

    try:
        file_path = file.name
        file_ext = os.path.splitext(file_path)[1].lower()

        # Handle PDF conversion
        if file_ext == '.pdf':
            status = "üìÑ Converting PDF to images..."
            try:
                image_paths = convert_pdf_to_images(file_path, temp_dir)
                if not image_paths:
                    return "", None, None, "‚ùå No pages found in PDF"
                # Use first page for now (could be extended to handle multiple pages)
                process_image = image_paths[0]
                status += f" {len(image_paths)} page(s) found. Processing first page...\n"
            except Exception as e:
                return "", None, None, f"‚ùå PDF conversion failed: {str(e)}"

        elif file_ext in ['.jpg', '.jpeg', '.png']:
            process_image = file_path
            status = "üéº Processing sheet music...\n"

        else:
            return "", None, None, f"‚ùå Unsupported file format: {file_ext}. Please use JPG, PNG, or PDF."

        # Process with homr
        try:
            musicxml_path = process_with_homr(process_image, temp_dir)
            status += "‚úì MusicXML generated\n"
        except Exception as e:
            return "", None, None, f"‚ùå OMR failed: {str(e)}\n\nTip: Ensure the image is clear and well-lit."

        # Convert to ABC
        try:
            abc_text = musicxml_to_abc(musicxml_path)
            status += "‚úì ABC notation generated\n"
        except Exception as e:
            abc_text = f"Error: {str(e)}"
            status += "‚ö† ABC conversion failed\n"

        # Convert to MIDI
        midi_path = os.path.join(temp_dir, "output.mid")
        try:
            musicxml_to_midi(musicxml_path, midi_path)
            status += "‚úì MIDI generated\n"
        except Exception as e:
            midi_path = None
            status += f"‚ö† MIDI conversion failed: {str(e)}\n"

        # Copy files to persistent location for download
        output_dir = tempfile.gettempdir()
        final_musicxml = os.path.join(output_dir, "output.musicxml")
        final_midi = os.path.join(output_dir, "output.mid") if midi_path else None

        shutil.copy(musicxml_path, final_musicxml)
        if midi_path and os.path.exists(midi_path):
            shutil.copy(midi_path, final_midi)

        status += "\n‚úÖ Processing complete!"

        return abc_text, final_midi, final_musicxml, status

    except Exception as e:
        return "", None, None, f"‚ùå Unexpected error: {str(e)}"

    finally:
        # Cleanup temp directory
        try:
            shutil.rmtree(temp_dir)
        except:
            pass


# Gradio Interface
def create_ui():
    """Create Gradio interface."""

    with gr.Blocks() as demo:
        gr.Markdown(
            """
            # üéπ Sheet Music Transcriber
            Upload a photo or PDF of piano sheet music and get digital notation formats.
            """
        )

        with gr.Row():
            with gr.Column(scale=1):
                file_input = gr.File(
                    label="Upload Sheet Music",
                    file_types=[".jpg", ".jpeg", ".png", ".pdf"],
                    type="filepath"
                )
                process_btn = gr.Button("üéµ Transcribe", variant="primary", size="lg")
                status_output = gr.Textbox(
                    label="Status",
                    lines=8,
                    interactive=False,
                    placeholder="Upload a file and click Transcribe..."
                )

            with gr.Column(scale=1):
                with gr.Tabs():
                    with gr.Tab("ABC Notation"):
                        abc_output = gr.Textbox(
                            label="ABC Notation (Copy-Paste Ready)",
                            lines=15,
                            interactive=False,
                            buttons=["copy"]
                        )

                    with gr.Tab("MIDI"):
                        midi_output = gr.File(label="Download MIDI")
                        gr.Markdown(
                            """
                            üí° **Tip**: Download the MIDI file and import it into your DAW or music software.
                            """
                        )

                    with gr.Tab("MusicXML"):
                        musicxml_output = gr.File(label="Download MusicXML")
                        gr.Markdown(
                            """
                            üí° **Tip**: MusicXML can be opened in MuseScore, Finale, Sibelius, and other notation software.
                            """
                        )

        gr.Markdown(
            """
            ---
            ‚ö†Ô∏è **Beta**: Results may contain errors, especially on complex or handwritten scores.
            üîß **Best results**: Use clear, high-resolution images of printed sheet music.
            üìñ **Powered by**: [homr](https://github.com/liebharc/homr) (OMR) + [music21](https://web.mit.edu/music21/) (conversion)
            """
        )

        # Connect button to processing function
        process_btn.click(
            fn=process_sheet_music,
            inputs=[file_input],
            outputs=[abc_output, midi_output, musicxml_output, status_output]
        )

    return demo


if __name__ == "__main__":
    print("Starting Sheet Music Transcriber...")
    print("Checking homr installation...")

    if not check_homr_installation():
        print("\n‚ö†Ô∏è  WARNING: homr is not installed!")
        print("\nPlease install homr first:")
        print("1. git clone https://github.com/liebharc/homr.git")
        print("2. cd homr")
        print("3. poetry install --only main")
        print("4. poetry run homr --init")
        print("\nThen return to this directory and run: python app.py")
        print("\nContinuing anyway (app will show error message to users)...\n")

    demo = create_ui()
    demo.launch(
        server_name="127.0.0.1",
        server_port=7860,
        share=False,
        theme=gr.themes.Soft(primary_hue="blue")
    )
